=====================================================================文件通配符==================================================================

文件通配符. 生产环境中由于硬盘很大,如果敲"ll"可能会导致大量输出导致机器死机等异常
	* 匹配零个或多个字符，但不匹配 "." 开头的文件，即隐藏文件
	? 匹配任何单个字符,一个汉字也算一个字符
	~ 当前用户家目录
	~mage 用户mage家目录
	. 和 ~+ 当前工作目录
	~- 前一个工作目录, 上一个目录, cd ~-  相当于 -
	[0-9] 匹配数字范围
	[a-z] 一个字母
	[A-Z] 一个字母
	[wang] 匹配列表中的任何的一个字符
	[^wang] 匹配列表中的所有字符以外的字符
	[^a-z] 匹配列表中的所有字符以外的字符
	
别外还有在Linux系统中预定义的字符类
	[:digit:]：任意数字，相当于0-9
	[:lower:]：任意小写字母,表示 a-z
	[:upper:]: 任意大写字母,表示 A-Z
	[:alpha:]: 任意大小写字母
	[:alnum:]：任意数字或字母
	[:blank:]：水平空白字符
	[:space:]：水平或垂直空白字符
	[:punct:]：标点符号
	[:print:]：可打印字符
	[:cntrl:]：控制（非打印）字符
	[:graph:]：图形字符
	[:xdigit:]：十六进制字符	


实例:
	ls *.txt
	ls ???.txt
	ll ~-/anaconda-ks.cfg
	ls f[abcd].txt   
	ls f[a-d].tx	# a-d 表示 a、A、b、B、c、C、d, 注意少了D
	ls f[A-D].txt	# A-D 表示  A、b、B、c、C、d、D, 注意少了a


=====================================================================正则表达式==================================================================

通配符功能是用来处理文件名(匹配现有的文件，不是生成文件)，而正则表达式是处理文本内容中字符

正则表达式被很多程序和开发语言所广泛支持：
	vim, less,grep,sed,awk, nginx,mysql 等

正则表达式引擎：
	采用不同算法，检查处理正则表达式的软件模块，如：PCRE（Perl Compatible Regular Expressions）

正则表达式的元字符分类：字符匹配、匹配次数、位置锚定、分组

正则表达式分两类：
	基本正则表达式：BRE Basic Regular Expressions
	扩展正则表达式：ERE Extended Regular Expressions

帮助：
	man 7 regex
	
	
===============================================================基本正则表达式元字符==============================================================
	
==================================字符匹配===================================

.   			匹配任意单个字符，可以是一个汉字
[]   			匹配指定范围内的任意单个字符，示例：[wang]   [0-9]   [a-z]   [a-zA-Z]
[^] 			匹配指定范围外的任意单个字符,示例：[^wang] 
[:alnum:] 		字母和数字
[:alpha:] 		代表任何英文大小写字符，亦即 A-Z, a-z
[:lower:] 		小写字母,示例:[[:lower:]],相当于[a-z]
[:upper:] 		大写字母
[:blank:] 		空白字符（空格和制表符）
[:space:] 		包括空格、制表符(水平和垂直)、换行符、回车符等各种类型的空白,比[:blank:]包含的范围广
[:cntrl:] 		不可打印的控制字符（退格、删除、警铃...）
[:digit:] 		十进制数字
[:xdigit:]		十六进制数字
[:graph:] 		可打印的非空白字符
[:print:] 		可打印字符
[:punct:] 		标点符号
\w 				#匹配单词构成部分，等价于[_[:alnum:]]
\W 				#匹配非单词构成部分，等价于[^_[:alnum:]]
\S     			#匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\s     			#匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意
Unicode 		正则表达式会匹配全角空格符


==================================匹配次数===================================

*  				#匹配前面的字符任意次，包括0次，贪婪模式：尽可能长的匹配
.* 				#任意长度的任意字符
\? 				#匹配其前面的字符出现0次或1次,即:可有可无
\+ 				#匹配其前面的字符出现最少1次,即:肯定有且 >=1 次
\{n\} 			#匹配前面的字符n次
\{m,n\} 		#匹配前面的字符至少m次，至多n次
\{,n\}  		#匹配前面的字符至多n次,<=n
\{n,\}  		#匹配前面的字符至少n次

==================================位置锚定===================================

^ 					#行首锚定, 用于模式的最左侧
$ 					#行尾锚定，用于模式的最右侧
^PATTERN$ 			#用于模式匹配整行
^$ 					#空行
^[[:space:]]*$ 		#空白行
\< 或 \b   			#词首锚定，用于单词模式的左侧
\> 或 \b        	#词尾锚定，用于单词模式的右侧
\<PATTERN\>     	#匹配整个单词

====================================分组=====================================

分组：() 将多个字符捆绑在一起，当作一个整体处理，如：\(root\)+
后向引用：
	分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \1, \2, \3, ...
	\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符

\(string1\(string2\)\)
\1 ：string1\(string2\)
\2 ：string2

====================================或者=====================================

a\|b 			#a或b  
C\|cat 			#C或cat   
\(C\|c\)at 		#Cat或ca


实例:
	grep "r..t" /etc/passwd			# 正则表达式最好加上双引号或单引号, grep 默认使用的是 基本正则表达式
	echo abc | grep "a\.c"			# 加双引号和不加双引号效果不一样	
	
	ls file[a-d].txt
	ls | grep "file[a-d].txt"		# [a-d]就是abcd，没有大小字母

	ls | grep "file[[:lower:]].txt"
	ls | grep "file[^a.z].txt"		# [^a.z] 除了a.z 之外的字符
	
	echo google | grep "go\{2\}gle"	# 匹配次数，通配符没有这个功能
	
	echo ggooogle | grep "go*gle"	# "o*"表示o出现0次或任意次
	
	echo ggooogle | grep "go.*gle"	# 任意长度的任意字符
	
	grep "^root" /etc/passwd
	grep "^#" /etc/fstab 
	grep "^[^#]" /etc/fstab					# 会自动过滤空行，因为 [^#] 表示一个字符，使用"cat -A /etc/fstab"可以看到空行有一个$
	grep "bash$" /etc/fstab					# 以bash结尾
	grep "^$" /etc/fstab					# 找到 " /etc/fstab" 中的空行, 使用"cat -A /etc/fstab"可以看到空行只有一个$
	grep -n "^[[:space:]]*$" /etc/fstab		# 找到空行或者包含空格、制表符的空行，-n显示行号
	
	echo linux-unix | grep '\<un' 			# linux中字母,数字,下划线都算单词的内部符号,  除了这些都算单词分隔符，比如 "-" " "等都算单词的分界
	echo linux-unix | grep '\bun'
	
	echo linux-unix | grep 'nux\>'
	echo linux-unix | grep 'nux\b'
	
	echo macoc linux-unix windows | grep '\<linux\>'
	
	ifconfig | grep 'inet' | grep "[0-9]\{1,3\}\.\{3\}[0-9]\{1,3\}\."
	
	ifconfig | grep 'inet' | grep -o '[0-9]\{1,3\}.[0-9]\{1,3\}.[0-9]\{1,3\}.[0-9]\{1,3\}'
	ifconfig | grep 'inet' | grep -o '\([0-9]\{1,3\}.\)\{3\}[0-9]\{1,3\}'			# -o 表示只显示匹配到的部分	
	
	echo abcabcabc | grep "\(abc\)\{3\}"																# 分组
	echo "abc123xyzabc123xyz" | grep '\([a-zA-Z]\{3\}\)\([0-9]\{3\}\)\([a-zA-Z]\{3\}\)\1\2\3'			# 向后引用
		\1  代表  \([a-zA-Z]\{3\}\)
		\2  代表  \([0-9]\{3\}\)
		\3  代表  \([a-zA-Z]\{3\}\)
		向后引用成立的条件，前面的内容和后面的有规律的重复,  比如"abcabc",可以对abc向后引用, "abcabd"就不适合对abc的引用
		
	
	echo 1 | grep '1\|2'
	echo 1abc | grep '1\|2abc'   		# 匹配 1 或者 2abc
	echo 1abc | grep '\(1\|2\)abc'   	# 匹配 1abc 或者 2abc
	

===============================================================扩展正则表达式元字符==============================================================

==================================字符匹配===================================

. 				任意单个字符
[wang] 			指定范围的字符
[^wang] 		不在指定范围的字符
[:alnum:] 		字母和数字
[:alpha:] 		代表任何英文大小写字符，亦即 A-Z, a-z
[:lower:] 		小写字母,示例:[[:lower:]],相当于[a-z]
[:upper:] 		大写字母
[:blank:] 		空白字符（空格和制表符）
[:space:] 		水平和垂直的空白字符（比[:blank:]包含的范围广）
[:cntrl:] 		不可打印的控制字符（退格、删除、警铃...）
[:digit:] 		十进制数字
[:xdigit:]		十六进制数字
[:graph:] 		可打印的非空白字符
[:print:] 		可打印字符
[:punct:] 		标点符号


==================================次数匹配===================================

*   			匹配前面字符任意次
? 				0或1次
+ 				1次或多次
{n} 			匹配n次
{m,n} 			至少m，至多n次

==================================位置锚定===================================

^ 				行首
$	 			行尾
\<, \b 			语首
\>, \b 			语尾

==================================分组其它===================================

() 					分组, 后向引用：\1, \2, ...
| 					或者
a|b 				#a或b
C|cat 				#C或cat
(C|c)at 			#Cat或cat


实例:
	grep -E          # 扩展正则表达式比基本正则表达式写起来更简洁,主要的区别就是扩展正则表达式不用加转义符\.
	
	ifconfig | grep 'inet' | grep -o -E "([0-9]{1,3}\.){3}[0-9]{1,3}"				# "\." 表示转义点
	
	echo "abc123xyzabc123xyz" | grep -E '([a-zA-Z]{3})([0-9]{3})([a-zA-Z]{3})\1\2\3'
	
	vim  /etc/passwd
		:/^b/,/^f/d									# 删除b到f行
		:%s/r..t/admin/g
		
	echo 4310121 | grep -E '\<[0-9]{6,12}\>'        # 匹配QQ号, \< 和 \> 表示以数字开头和结尾
 		
	echo kkk_en@163.com | grep -E '[[:alnum:]_-]+@[[:alnum:]_]+\.[[:alnum:]_]+'
		
	echo 18988889999 | grep -E '\<1[3456789][0-9]{9}\>'
	
	
	