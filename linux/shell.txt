
=======================================================================shell=====================================================================


#!/bin/bash						#首行She-bang机制

curl "https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh" | bash
curl -s "https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh"  			# -s 隐藏下载过程

wget -O - "https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh" | bash

bash -n tcpx.sh			# -n 检查语法
 
 

==============================内置变量+普通变量==============================

内置变量，如：PS1，PATH，UID，HOSTNAME，$$，BASHPID，PPID，$?，HISTSIZE
用户自定义变量，不管什么类型，默认全部是字符串. 变量名区分大小写，不能数字开头. 支持字母、数字、下划线

ab=`whoami`
unset ab

echo ${title}_$name     # 如果不加{},会把"title_"当成一个变量


dcmd='ls -al'			# 实现动态命令
$dcmd


nums=`seq 10`
echo $nums				# 一行显示
echo "$nums"			# 加双引号，保留原格式，10行显示
echo '$nums'			# 加单引号, $失去变量的功能，只是普通的字符

title=cto
title+=ceo				# 追加字符串


set 					# 显示所有变量

==================================环境变量===================================

环境变量(了解),用的不多,通常都是在shell环境种用,在脚本种很少用，环境变量主要是配置shell环境,也就是交互式运行命令用:
	可以使子进程（包括孙子进程）继承父进程的变量，但是无法让父进程使用子进程的变量
	一旦子进程修改从父进程继承的变量，会将新的值传递给孙子进程
	一般只在系统配置文件中使用，在脚本中较少使用

echo $BASHPID			# 用户登录后,实际上在一个shell中，查看shell进程编号

pstree -p				# 查看进程之间的关系， 运行一个命令, 实质上就是在当前shell中开启一个子进程， 比如运行 "bash"


name=opc
bash					# 开启子进程
echo $name				# 这里name无值,说明普通变量的有效范围在当前shell,对子进程无效


name=opc
export opc				# 将普通变量提升为环境变量
bash
echo $name				# 打印出name值，说明父进程的变量可以传递给子进程

export name=opc			# 声明环境变量, 也可使用 declare -x name=opc

export					# 查看环境变量. env、printenv、declare -x , 这三个命令也可查看环境变量.  env 等价于 printenv，export 等价于 declare -x 
	
unset					# 可删除环境变量

cat /proc/$进程编号/environ		# 查看进程的环境变量


==================================只读变量===================================

readonly name=opc		# 也可以使用 declare -r name=opc 定义
	
readonly				# 列出当前 shell 环境中所有用户定义的只读变量，输出格式简洁，适合快速查看. 等价于 declare -r
readonly -p				# 列出所有只读变量(包括用户定义和系统内置),包含系统内置只读变量(如 BASHOPTS, BASHPID 等)

unset name				# 不能使用 unset 删除一个只读变量.  可以 exit 退出，然后再login，变量就会失效


bash --version
eclare +r PI   			# 移除只读标志，Bash 4.4+ 可以通过这个方式移除只读变量
unset PI       			# 成功删除
echo $PI       			# 空

==================================位置变量===================================

$1, $2, ... 		对应第1个、第2个等参数，脚本中 $10 要写为 ${10}, 否则会被解释为 $1 和 0 , ${10}以上都要加{}.
$0 					命令本身,包括路径
$# 					传递给脚本的参数的个数
$* 					传递给脚本的所有参数，全部参数合为一个字符串(了解)
$@ 					传递给脚本的所有参数，每个参数为独立字符串(了解)

$@ 和 $* 只在被双引号包起来的时候才会有差异(了解)

set --				清空所有位置变量(了解)


==================================状态变量===================================

$?的值为0 			#表示前一个命令运行成功
$?的值是1到255 		#表示前一个命令运行失败


exit [n]			#可以在脚本中使用以下命令自定义退出状态码, 比如 exit 100	
exit 100			#通过 $? 取出的状态码就是100


脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字
如果exit后面无数字,终止退出状态取决于exit命令前面命令执行结果
如果没有exit命令, 即未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码


==================================展开命令===================================

各种符号处理的优先级:
	把命令行分成单个命令词
	展开别名
	展开大括号的声明{}
	展开波浪符声明 ~
	命令替换$() 和 ``
	再次把命令行分成命令词
	展开文件通配*、?、[abc]等等
	准备I/0重导向 <、>
	运行命令

防止扩展
	反斜线 \ 会使随后的字符按原意解释	
	单引号（’’）防止所有扩展
	双引号（""）也可防止扩展，但是以下情况例外：$变量


==================================set命令====================================

set 命令实现脚本安全
	-u 在扩展一个没有设置的变量时，显示错误信息， 等同 set -o nounset
	-e 如果一个命令返回一个非0退出状态值(失败)就退出， 等同 set -o errexit
	-o option 显示，打开或者关闭选项
		显示选项：set -o
		打开选项：set -o 选项
		关闭选项：set +o 选项
	-x 当执行命令时，打印命令及其参数,类似 bash -x

	
#!/bin/bash
set -e			#在工作中,脚本都要加上 -e 和 -u 参数!!! (重要)
set -u



(了解) set 命令可以用来定制 shell 环境
	[opc@docker-halo ~]$ echo $-  			# - 变量记录当前设置的shell选项，himBH是默认值
	imBH									# imBH每个字母代表特定的含义，比如 B 代表支持{}, set +B 关闭花括号功能，set -B 则打开
	
==================================提示信息===================================

echo		# 不能格式化输出
printf		# 可以格式化输出，可以使显示的界面更加漂亮. echo 的所有功能 printf 都支持, 比如打印出字体颜色


printf '%s\n' 1 2 3    		# 需要自己加换行符

printf '(%s)' 1 2 3			# 给数字加上括号 


==================================算术运算===================================

注意：bash 只支持整数，不支持小数

实现算术运算：
	(1) let var=算术表达式   			 # 掌握, 等价 ((var=算术表达式))
	(2) var=$[算术表达式]				 # 掌握		
			echo $[RANDOM%100+1]
	(3) var=$((算术表达式))				 # 掌握	 	
	(4) var=$(expr arg1 arg2 arg3 ...)
			expr $x \* $y
	(5) declare -i var = 数值
		declare声明变量：https://www.cnblogs.com/gltou/p/15095801.html
	(6) echo '算术表达式' | bc			# bc支持小数
		echo $x*$y | bc

help let


==================================逻辑运算===================================

&	与, 一假则假,全真才真
|	或, 一真则真,全假才假
！  非(取反)
^	异或，相同为假，不同为真    (基本不用)
	1 ^ 0 = 1
	1 ^ 1 = 0
	
&&
||
	第一个CMD1结果为真 (1)，总的结果必定为1，因此不需要执行CMD2
	第一个CMD1结果为假 (0)，第二个CMD2 必须要参与运算,才能得到最终的结果



================================条件测试命令=================================

条件测试命令，EXPRESSION前后必须有空白字符，也就是说 [] 前后一定有空格
	test EXPRESSION
	[ EXPRESSION ] 			# 和test 等价，建议使用 [ ]
	[[ EXPRESSION ]] 		# 相当于增强版的 [ ], 支持[]的用法,且支持扩展正则表达式和通配符(这里不是匹配文件名，用来匹配字符串)

[ EXPRESSION ]
    File operators:
      -a FILE        True if file exists.(取反结果不对，建议使用 -e )
	  -e FILE        True if file exists.
	  -d FILE        True if file is a directory.
	  -f FILE        True if file exists and is a regular file.
      -r FILE        True if file is readable by you.
	  -w FILE        True if the file is writable by you.
      -x FILE        True if the file is executable by you.
      -s FILE        True if file exists and is not empty.
      -S FILE        True if file is a socket.
      -t FD          True if FD is opened on a terminal.
      -O FILE        True if the file is effectively owned by you.
      -G FILE        True if the file is effectively owned by your group.
      -N FILE        True if the file has been modified since it was last read.

      FILE1 -nt FILE2  True if file1 is newer than file2 (according to modification date).
      FILE1 -ot FILE2  True if file1 is older than file2.
      FILE1 -ef FILE2  True if file1 is a hard link to file2.

    String operators:
      -z STRING      True if string is empty.  变量不存在或变量的值为空，-z 都会判断为空
      -n STRING
         STRING      True if string is not empty. 判断可以不写 -n , 直接写字符串

      STRING1 = STRING2
                     True if the strings are equal.   注意比较有空格，没有空格相当于赋值 . 这里是比较字符串
      STRING1 != STRING2
                     True if the strings are not equal.
      STRING1 < STRING2
                     True if STRING1 sorts before STRING2 lexicographically.
      STRING1 > STRING2
                     True if STRING1 sorts after STRING2 lexicographically.

    Other operators:

      -o OPTION      	True if the shell option OPTION is enabled.
      -v VAR    	 	True if the shell variable VAR is set
      ! EXPR         	True if expr is false.
      EXPR1 -a EXPR2 	True if both expr1 AND expr2 are true.
      EXPR1 -o EXPR2 	True if either expr1 OR expr2 is true.

      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne, -lt, -le, -gt, or -ge. 这里比较数字
	
	
	
条件命令两种结果:
	若真，状态码变量 $?为0
	若假，状态码变量 $?为1


实例:

	type test
	type [
	type [[

	help test
	help test
	
	CMD1 && CMD2 || CMD3		# CMD1成功 -> CMD2运行 —> CMD3不运行;  CMD1失败 -> CMD3运行; 
	CMD1 || CMD2 && CMD3		# CMD1成功 ——> CMD2不运行 -> CMD3运行;  CMD1不成功 -> CMD2运行 -> CMD3运行; 工作中不这样写，因为CMD3始终会运行 

	[ `whoami` = 'opc' -a ! -e ./testDir  ] && mkdir ./testDir || echo 'testDir is exists'    			# -a 把两个判断表达式连在一起，都运行成功才是true 
	[ \( `whoami` = 'opc' \) -a \( ! -e ./testDir \) ] && mkdir ./testDir || echo 'testDir is exists'   # 加括号可以使表达式更清晰
	
	[ $a = $b ] && echo equal || echo not equal		     # 如果$a有值, $b不存在或空值,会报语法错误,给变量加双引号可防止语法错误. [[ ]] 无此问题,但最好加引号养成习惯
		b=							# 什么值都不给，会报语法错误
		b=""						# 给空值也会报语法错误
		不声明b变量					# 也会报语法错误
	
	[ "$a" = "$b" ] && echo equal || echo not equal	     # 加上双引号,即使$b不存在或空值,也有空字符串占位,而不会出现语法错误
	

[[ EXPRESSION ]]
	( EXPRESSION )		Returns the value of EXPRESSION
    ! EXPRESSION		True if EXPRESSION is false; else false
    EXPR1 && EXPR2		True if both EXPR1 and EXPR2 are true; else false
    EXPR1 || EXPR2		True if either EXPR1 or EXPR2 is true; else false
	
	== 或 !=			# 判断字符串是否相等,  == 号的右边作为通配符
	=~					# 判断字符串相等, =~ 号的右边作为扩展正则表达式
	
	如果EXPR1足以确定表达式的值，则&&和||运算符不会计算EXPR2	

实例:
	[[ $file == *.sh ]] && echo true || echo false
	[[ "$file" == *.sh ]] && echo true || echo false
	
	[[ "$file" =~ .*\.sh$ ]] && echo true || echo false


===================================()和{}====================================

( list ) 会开启子shell,并且list中变量赋值及内部命令执行后,将不再影响后续的环境 
	查看帮助:
		man bash
		/\(list\)
		
{ list; } 不会启子shell, 在当前shell中运行,会影响当前shell环境
	查看参看
		man bash 
		/{ list; }

实例:
	name=oracle;( name=opc;echo $name );echo $name		# 第一个name打印出opc,第二个name打印出 oracle 
	( cd /data/dir/; rm -rf * )		# 当这个命令运行完后,还是在原目录, 因为()不改变外部shell环境,在脚本中临时做些事情就可以用 ()

	
扩展:
	dir 有文件, dirlink 是 dir 的软连接.
		rm -rf  dirlink/				# 软连接和dir都没删，dir 下的目录已清空
		rm -rf  dirlink					# 软连接删了，dir和dir下的问价你还在
	

==================================read命令===================================

read从标准输入中读取值，给每个单词分配一个变量，所有剩余单词都被分配给最后一个变量，如果没有指定变量名，默认赋值给系统内置变量 REPLY

read 可以用来在脚本中实现交互性操作

read [options] [name ...]
	-p 			指定提示信息
	-t N 		N秒内没输入就退出
	-s 			静默输入，一般用于密码
	-n N 		指定输入的字符长度N
	-d '字符' 	输入结束符
	



read name age weight   	# 输入 zhangsan 28 60 80
echo $name				# zhangsan
echo $age				# 28	
echo $weight			# 60 80	

read -p "pls input your name: " name
echo $name

read -d c name          # 当有c字符输入就退出，只支持字符, 不支持输入单词


============================bash shell 配置文件==============================

所有用户皆有效
	/etc/profile
	/etc/profile.d/*.sh
	/etc/bashr
	
特定用户有效
	~/.bash_profile
	~/.bashrc

交互式登录:
	两种方式:
		直接通过终端输入账号密码登录
		使用 su - UserName 切换的用户
	
	通过终端登录 或 使用"su - UserName"切换将运行的配置文件(配置文件的生效顺序从上到下,实际是文件调用文件的顺序): 
		/etc/profile
		/etc/profile.d/*. sh
		/etc/bashrc					# rc=run command
		~/.bash_profile
		~/.bashrc
		/etc/bashrc

非交互式登录(了解)
	四种方式:
		su UserName
		图形界面下打开的终端
		执行脚本
		任何其它的bash实例
	
	非交互式登录涉及到的配置文件有(配置文件的生效顺序从上到下):
		/etc/profile.d/*.sh
		/etc/bashrc
		~/.bashr

profile类 和 bashrc类 理论上任何linux命令都可以往里面放. 
	
	Profile类: profile类为交互式登录的shell提供配置
		全局：
			/etc/profile
			/etc/profile.d/*.sh
		个人：
			~/.bash_profile
		用途：
			一般放环境变量，以及运行命令或脚本
			
	bashrc类：为非交互式和交互式登录的shell提供配置			
		全局：
			/etc/bashrc
		个人：
			~/.bashrc
		用途：
			一般定义命令别名和函数, 以及 定义本地变量
			
	人为规定，并非强制		
			
		
修改profile和bashrc文件后需生效两种方法:
	重新启动shell进程,比如退出shell重新登录
	source 或 . 配置文件， souce 等价 .
		source
		. ~/.bashrc
	
	注意: source 会在当前shell中执行脚本, 所有一般只用于执行置文件,或在脚本中调用另一个脚本的场景
	
	
用户退出bash会触发"~/.bash_logout"运行. 可以实现 创建自动备份、清除临时文件 等功能.


==================================流程运算===================================

if 判断; then
	...
elif 判断; then
	...
elif 判断; then
	...
else
	...
fi	


case 变量引用 in
PAT1)
	分支1
	;;
PAT2)
	分支2
	;;
*)
	默认分支
	;;
esac

case的PAT支持glob风格的通配符：
	* 		任意长度任意字符
	? 		任意单个字符
	[] 		指定范围内的任意单个字符
	| 		或者，如: a|b



for循环：
	
	CentOS7的for帮助比CentOS8全面, CentOS7 的帮助上面提到了for循环的格式2的写法
		help for

	格式1：
	
		for NAME [in WORDS ... ] ; do COMMANDS; done
		
		for 变量名 in 列表;do
			循环体
		done
		
	
		for 变量名  in 列表
		do
			循环体
		done
	
	格式2：双小括号方法，即((…))格式，也可以用于算术运算，双小括号方法也可以使 bash Shell 实现C语言风格的变量操作 I=10;((I++))
		
		for ((: for (( exp1; exp2; exp3 )); do COMMANDS; done
		
		for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))
		do
			循环体
		done

	实例；
		for i; do								#  If `in WORDS ...;' is not present, then `in "$@"' is assumed
		
		for i in 1 2 3;do echo i=$i;done
		
		n=5; for i in `seq $n`;do echo i=$i;done
		
		for i in {1..5};do echo i=$i;done		# 不支持 "n=5; {1..$n}" 这种写法，可以使用 echo {1..$n} 看到结果
		
		for i in *.sh;do echo i=$i;done			# 支持通配符
		
		for i in /home/opc/*.sh;do echo i=$i;done
		
		sum=0; for ((i=0;i<=100;i++))
		
		for ((sum=0,i=1;i<=100;i++))
		

while 循环 

	while COMMANDS; do COMMANDS; done
	
	while CONDITION; do
		循环体
	done


until 循环 (了解,用的很少)

	until COMMANDS; do COMMANDS; done
	
	until CONDITION; do
		循环体
	done

循环控制语句 
	continue， continue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层
	break，break [N]：提前结束第N层整个循环，最内层为第1层
	shift 命令
		shift [n] 用于将参量列表 list 左移指定次数，缺省为左移一次。
		参量列表 list 一旦被移动，最左端的那个参数就从列表中删除。while 循环遍历位置参量列表时，常用到 shift
	
while 特殊用法 while read, 遍历文件或文本的每一行
	
	while read line; do
		循环体
	done < /PATH/FROM/SOMEFILE
	
	
循环与菜单 select

	select NAME [in WORDS ... ;] do COMMANDS; done
		
	select variable in list ;do 
		循环体命令
	done
	
	实例：
		select MENU in 北京烤鸭 佛跳墙 小龙虾 羊蝎子 火锅 点菜结束;do echo $MENU; done
	
		
	说明：
		1. select 循环主要用于创建菜单，按数字顺序排列的菜单项显示在标准错误上，并显示 PS3 提示符，等待用户输入
		2. 用户输入菜单列表中的某个数字，执行相应的命令
		3. 用户输入被保存在内置变量 REPLY 中
		4. select 是个无限循环，因此要用 break 命令退出循环，或用 exit 命令终止脚本。也可以按 ctrl+c 退出循环
		5. select 经常和 case 联合使用
		6. 与 for 循环类似，可以省略 in list，此时使用位置参量
	
	
	
	
	
	
	
	
	